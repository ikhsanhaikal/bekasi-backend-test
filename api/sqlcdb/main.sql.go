// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: main.sql

package sqlcdb

import (
	"context"
)

const soalDua = `-- name: SoalDua :many
select id, firstname, lastname, hiredate, terminationdate, salary from employees e
where e.terminationdate isnull
and lastname = 'smith'
order by
	lastname asc,
	firstname asc
`

func (q *Queries) SoalDua(ctx context.Context) ([]Employee, error) {
	rows, err := q.db.Query(ctx, soalDua)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Employee
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.ID,
			&i.Firstname,
			&i.Lastname,
			&i.Hiredate,
			&i.Terminationdate,
			&i.Salary,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const soalEmpat = `-- name: SoalEmpat :one
select max(e.hiredate) as terbaru, min(e.hiredate) as tua,
 MAX(e.hiredate)- MIN(e.hiredate) AS DateDifference  
from employees e
`

type SoalEmpatRow struct {
	Terbaru        interface{}
	Tua            interface{}
	Datedifference int32
}

func (q *Queries) SoalEmpat(ctx context.Context) (SoalEmpatRow, error) {
	row := q.db.QueryRow(ctx, soalEmpat)
	var i SoalEmpatRow
	err := row.Scan(&i.Terbaru, &i.Tua, &i.Datedifference)
	return i, err
}

const soalLima = `-- name: SoalLima :many
select id, firstname, lastname, hiredate, terminationdate, salary from employees e
`

func (q *Queries) SoalLima(ctx context.Context) ([]Employee, error) {
	rows, err := q.db.Query(ctx, soalLima)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Employee
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.ID,
			&i.Firstname,
			&i.Lastname,
			&i.Hiredate,
			&i.Terminationdate,
			&i.Salary,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const soalLimaCountTotalUlasan = `-- name: SoalLimaCountTotalUlasan :many
select e.id, count(a.empid) as total 
from 
  employees e
  left join annualreviews a on a.empid = e.id 
GROUP BY 
  e.id
`

type SoalLimaCountTotalUlasanRow struct {
	ID    int32
	Total int64
}

func (q *Queries) SoalLimaCountTotalUlasan(ctx context.Context) ([]SoalLimaCountTotalUlasanRow, error) {
	rows, err := q.db.Query(ctx, soalLimaCountTotalUlasan)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SoalLimaCountTotalUlasanRow
	for rows.Next() {
		var i SoalLimaCountTotalUlasanRow
		if err := rows.Scan(&i.ID, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const soalTiga = `-- name: SoalTiga :many
select e.id, e.firstname, e.lastname, e.hiredate, e.terminationdate, e.salary
from 
  employees e
  left join annualreviews a on a.empid = e.id
  where empid isnull 
order by 
  e.hiredate
`

func (q *Queries) SoalTiga(ctx context.Context) ([]Employee, error) {
	rows, err := q.db.Query(ctx, soalTiga)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Employee
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.ID,
			&i.Firstname,
			&i.Lastname,
			&i.Hiredate,
			&i.Terminationdate,
			&i.Salary,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
